# 2 주 차

1. 프로세스
    - 프로세스
    - 프로세스 스케줄링
    - 프로세스간 통신
    - PCB와 Context Switching
    - IPC
2. 스레드
    - 프로세스와 스레드의 차이
    - 다중 코어 프로그래밍
    - 다중 스레드 모델
    
    프로세스란?
    
    ```
    프로세스(process)란실행중에 있는 프로그램(Program)을 의미한다.
    
    스케줄링의 대상이 되는 작업(task)과 같은 의미로 쓰인다.
    
    프로세스 내부에는 최소 하나의 스레드(thread)를 가지고있는데, 실제로는 스레드(thread)단위로 스케줄링을 한다.
    
    하드디스크에 있는 프로그램을 실행하면, 실행을 위해서메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 프로세스라불린다.
    ```
    
    메모리 구조
    
    ![Untitled](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/Untitled.png)
    
    ```
    Code영역: 프로그램을 실행시키는 실행 파일 내의 명령어들이 올라갑니다.
    (쉽게 말하면 소스코드가 올라간다고 생각하면 됨)
    Data영역 : 전역변수, static 변수의 할당.
    Heap영역 : 동적할당을 위한 메모리 영역.
    - C언어 : malloc & free // C++ : new & delete // JAVA : new & (java에서 메모리 해제는..가비지컬렉터가 알아서해주는거로 앎..아니면 객체 null)
    Stack 영역 : 지역변수, 함수 호출시 전달되는 인자(파라미터)를 위한 메모리 영역.
    ```
    
    ```
    3. 프로세스 스케줄링 (Process Scheduling)CPU는 하나인데 동시에 실행되어야 할 프로세스가 여러 개
    -> CPU가 고속으로 여러 프로세스를 일정한 기준으로 순서를 정해서 실행한다.
    
    스케줄링(Scheduling)
    -CPU 할당 순서 및 방법을 결정하는 일. (어떤 프로세스를 running 상태로 보낼까?)
    - 일정한 기준 : scheduling algorithm 을 통해서.**대부분의 OS에서는우선순위(Priority algorithm) 알고리즘과 라운드 로빈(Round Robin) 알고리즘을 혼합해서 스케줄링 하는것으로 알고있습니다.
    ```
    
    프로세스간  내부 통신 = IPC
    
    서로 다른 프로세스간 데이터를 주고받을 수 있음.
    
    동시 접근 가능한 메모리 즉 공유 메모리가 핵심.
    
    파이프라는 개념 등장.
    
    (프로세스는 자원이 별도 할당되고 스레드는 공유자원이기 때문에 프로세스간 통신이 더 어렵다)
    
    **Process Management<pcb랑 contextswitching>**
    
    CPU가 프로세스가 여러 개일 때, CPU 스케줄링을 통해 관리하는 것을 말합니다.
    
    이때, CPU는 각 프로세스들이 누군지 알아야 관리가 가능합니다.
    
    이러한 프로세스들의 특징을 갖고 있는 것이 바로 **Process Metadata**입니다.
    
    Process Metadata에는 다음과 같은 정보들이 있습니다.
    
    - Process ID : PID(Process Identification Number) 라고도 합니다.
    
    : 프로세스 고유 식별 번호
    
    - Process State(프로세스 상태)
    
    : 프로세스의 현재 상태(준비, 실행, 대기 상태)를 기억시킵니다.
    
    - Process Priority(스케줄링 정보)
    
    : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 기억시킵니다.
    
    - CPU Registers
    
    : 프로세스의 레지스터 상태를 저장하는 공간 등. CPU 내 범용 레지스터(AX, BX, CX, DX), 데이터 레지스터(SP, BP, SI, DI), 세그먼트 레지스터(CS, DS, ES, SS) 등이 갖고 있는 값을 기억시킵니다.
    
    - Owner(계정 정보)
    
    : CPU 사용시간의 정보(Quantum), 각종 스케줄러에 필요한 정보를 기억시킵니다.
    
    - 기억장치 관리 정보
    
    : 프로그램이 적재될 기억 장치의 상한치, 하한치, 페이지 테이블 등의 정보를 기억시킵니다.
    
    - 입출력 정보
    
    : 프로세스 수행 시 필요한 주변 장치, 파일들의 정보를 기억시킵니다.
    
    - 프로그램 카운터(계수기)
    
    : 다음에 실행되는 명령어의 주소를 기억시킵니다.
    
    이러한 정보들이 담긴 메타데이터는 프로세스가 생성되면 **PCB(Process Control Block)**이라는 곳에 저장이 됩니다.
    
    **PCB(Process Controll Block)**
    
    프로세스 메타데이터들을 저장해 놓는 곳입니다. 하나의 PCB 안에는 하나의 프로세스의 정보가 담겨있습니다.(커널 스택에 위치함)
    
    ![https://mblogthumb-phinf.pstatic.net/MjAyMDA3MDNfMzYg/MDAxNTkzNzQ2NDQwNTYw.f62otrPY3iNE4edLaxgkM1F3YRBJAVAzJkc0z1FJR8Eg.tr73Ug8AtaJViK2yoGYAlOrZcDQBxYWyYQRwtbsLTJgg.PNG.adamdoha/image.png?type=w800](https://mblogthumb-phinf.pstatic.net/MjAyMDA3MDNfMzYg/MDAxNTkzNzQ2NDQwNTYw.f62otrPY3iNE4edLaxgkM1F3YRBJAVAzJkc0z1FJR8Eg.tr73Ug8AtaJViK2yoGYAlOrZcDQBxYWyYQRwtbsLTJgg.PNG.adamdoha/image.png?type=w800)
    
    **프로그램 실행 -> 프로세스 생성 -> 프로세스 주소 공간에 (코드, 데이터, 스택) 생성 -> 이 프로세스의 메타데이터들이 PCB에 저장**
    
    **PCB(Process Control Block) 상세 구조**
    
    ![https://mblogthumb-phinf.pstatic.net/MjAyMDA3MDNfMTg0/MDAxNTkzNzQ1MjQ2Njgz.nmhyRLo_ygWgF9piW8BUwmCgcgq-W2HIeAW0Wxc1Kqcg.MS4ZFBQU7TGOFC1JtXVLkANPgrIyKgdb1tcp2laV6zQg.PNG.adamdoha/image.png?type=w800](https://mblogthumb-phinf.pstatic.net/MjAyMDA3MDNfMTg0/MDAxNTkzNzQ1MjQ2Njgz.nmhyRLo_ygWgF9piW8BUwmCgcgq-W2HIeAW0Wxc1Kqcg.MS4ZFBQU7TGOFC1JtXVLkANPgrIyKgdb1tcp2laV6zQg.PNG.adamdoha/image.png?type=w800)
    
    - Process State : 프로세스 상태(Create, Ready, Running, Block, terminated)
    - Process Counter : 다음 실행할 명령어의 주솟값
    - CPU Registers : accumulator, index register, stack pointers, general purpose registers.
    
    **PCB가 필요한 이유?**
    
    CPU에서는 프로세스의 상태에 따라 교체 작업이 이루어집니다. (인터럽트가 발생해서 할당받은 프로세스가 Block 상태가 되고 다른 프로세스를 running으로 바꿀 때)
    
    ![Untitled](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/Untitled%201.png)
    
    **이때, 앞으로 다시 수행할 Block 상태의 프로세스의 상태 값을 PCB에 저장해두는 것**입니다.
    
    **PCB의 관리 방식**
    
    Linked List 방식으로 관리가 됩니다.
    
    PCB List Head에 PCB들이 생성될 때마다 붙게 됩니다. 주솟값으로 연결이 이루어져 있는 연결 리스트 형태로, **삽입 삭제가 용이**합니다.
    
    **즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료 시 제거가 됩니다.**
    
    이렇게 수행 중인 프로세스를 변경할 때, **CPU의 레지스터 정보가 변경되는 것**을 **Context Switching이라고 합니다.**
    
    **Context Switching이 필요한 이유**
    
    만약 컴퓨터가 매번 하나의 Task만 처리할 수 있다면?
    
    - 다음 Task를 처리하기 위해서 현재 Task가 끝날 때까지 기다려야 합니다.
    - 반응속도가 매우 느리고 사용하기 불편합니다.
    
    **다양한 사람들이 동시에 사용하는 것처럼 하기 위해서 Context Switching이 필요하게 되었습니다.**
    
    - 컴퓨터 멀티태스킹을 통해 빠른 반응속도로 응답 가능합니다.
    - 빠르게 Task를 바꾸면서 실행하기에 사람은 실시간처리가 되는 것처럼 보입니다.
    - CPU가 Task를 바꿔가며 실행하기 위해 Context Switching이 필요하게 되었습니다.
    
    **Context Switching의 뜻**
    
    **CPU가 현재 실행하고 있는 Task(Process, Thread)의 상태를 저장하고, 다음 진행할 Task의 상태 및 Register 값들에 대한 정보(Context)를 읽어 새로운 Task의 Context 정보로 교체하는 과정**을 말합니다. 다르게 말하면, **CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어서 레지스터에 적재하는 과정을 말합니다.** 또 다르게 말해보면 **다중 프로그래밍 시스템에서 CPU가 할당되는 프로세스를 변경하기 위해 현재 CPU를 사용하여 실행되고 있는 프로세서의 상태 정보를 저장하고 제어권을 인터럽트 서비스 루틴(ISR)에게 넘기는 작업**을 말합니다.
    
    ****
    
    여기서 Context란 CPU가 다루는 Task(Process / Thread)에 대한 정보를 말하고, 대부분의 정보는 Register에 저장되고 PCB로 관리됩니다.
    
    ****
    
    인터럽트가 발생하거나, 실행 중인 CPU 사용 허가 시간을 모두 소모하거나, 입출력을 위해 대기해야 하는 경우 Context Switching이 발생합니다.
    
    즉, Context Switching은 프로세스가 Ready -> Running , Running -> Ready , Running -> Block 처럼 상태 변경 시에 발생합니다.
    
    **Context Switching 수행 과정**
    
    1. Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리가 되고 있습니다.
    
    2. 현재 실행하고 있는 Task의 PCB 정보를 저장하게 됩니다.(Process Stack, Ready Queue)
    
    3. 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있게 됩니다.
    
    **Context Switching Cost**
    
    Context Switching이 발생하게 되면 다음과 같은 Cost가 소요됩니다.
    
    1. Cache 초기화
    
    2. Memory Mapping 초기화
    
    3. 메모리의 접근을 위해서 Kernel은 항상 실행되어야 합니다.
    
    따라서 잦은 Context Switching은 성능 저하를 가져옵니다.
    
    **Context Switching과 Interrupt**
    
    CPU는 하나의 프로세스 정보만을 기억합니다. 여러 개의 프로세스가 실행되는 다중 프로그래밍 환경에서 CPU는 각각의 프로세스의 정보를 저장했다 복귀하고 다시 저장했다 복귀하는 일을 반복합니다. 프로세스의 저장과 복귀는 프로세스의 중단과 실행을 의미합니다. 프로세스의 중단과 실행 시 인터럽트가 발생하므로, 문맥 교환이 많이 일어난다는 것은 인터럽트가 많이 발생한다는 것을 의미합니다.
    
    **Context Switching과 시간 할당량**
    
    프로세스들의 시간 할당량은 시스템 성능의 중요한 역할을 합니다. 시간 할당량이 적을수록 사용자 입장에서는 여러 개의 프로세스가 거의 동시에 수행되는 느낌을 갖지만 인터럽트의 수와 문맥 교환의 수가 늘어납니다. 프로세스의 실행을 위한 부가적인 활동을 오버헤드(간접 부담 비용)이라고 하는데, 이 또한 문맥 교환 수와 같이 늘어나게 됩니다. 정리하자면 다음과 같습니다.
    
    - 시간 할당량이 적어지면 : 문맥 교환 수, 인터럽트 횟수, 오버헤드가 증가하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 갖는다.
    - 시간 할당량이 커지면 : 문맥 교환 수, 인터럽트 횟수, 오버헤드가 감소하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 갖지 못한다.
    
    **프로세스를 수행하다가 I/O event가 발생하여 BLOCK 상태로 전환시켰을 때, CPU가 그냥 놀게 놔두는 것보다 다른 프로세스를 수행시키는 것이 효율적**이므로, CPU에 계속 프로세스를 수행시키도록 하기 위해서 다른 프로세스를 실행시키고 Context Switching을 할 때 Overhead가 발생합니다.
    
    CPU가 놀지 않도록 만들면서, 사용자에게 빠르게 일처리를 제공해 주기 위한 것입니다.
    
    **Process vs Thread**
    
    Context Switching 비용은 Process가 Thread보다 많이 듭니다. 그 이유는 Thread는 Stack 영역을 제외한 모든 메모리를 공유하기에 Context Switching 발생 시 Stack 영역만 변경하면 됩니다.
    
    < ipc part>
    
    1. 공유 메모리
    
    ![sharedmemo.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/sharedmemo.png)
    
    공유 메모리가 데이터 자체를 공유하도록 지원하는 설비
    
    프로세스간 메모리 영역을 공유하도록 허용한다.
    
    프로세스가 공유메모리할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해주고 어떤 프로세스든 이 영역에 접근 가능하다.
    
    (공유 메모리가 각 프로세스에게 첨부 하는 방식으로 작동하게됨)
    
    = 각 프로세스가 메모리 영역에 첨부됨.
    
    프로세스간 RW모두 필요할 때  사용
    
    중개 없이 작동하므로 가장 빠르다.(대량의 정보를 다수의 프로세스에 배포가능)
    
    1. 파이프 
    
    ![pipe.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/pipe.png)
    
    통신을 위한 메모리공간(버퍼)를 생성해 프로세스가 데이터를 주고받게끔 한다.
    
    1. 익명 파이프
    
    일반적인 파이프
    
    통신할 프로세스가 명확히 알 수 있는경우
    
    (부모-자식, 형제 프로세스간)
    
    외부 프로세스에서 사용 불가능
    
    ![ex1.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/ex1.png)
    
    1. 네임드 파이프
    
    전혀 모르는 상태의 프로세스간 통신에 사용
    
    익명 파이프의 확장 상태로 부모와 무관한 다른 프로세스도 통신가능
    
    (이름이 있는 파일을 사용하기 때문에 가능)
    
    FIFO 파일을 사용해 서로 무관한 프로세스간 통신에 사용한다.(외부와도 가능)
    
    mkfifo or mknod로 생성함
    
    단점으로는 반이중통신→전이중통신을 위해서는 익명파이프처럼 2개를 만들어야함.
    
    1. 소켓
    
    ![socket.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/socket.png)
    
    ![sck1.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/sck1.png)
    
    ![msgQ.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/msgQ.png)
    
    ![memMap.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/memMap.png)
    
    ![RPC.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/RPC.png)
    
    ![summary.PNG](2%20%E1%84%8C%E1%85%AE%20%E1%84%8E%E1%85%A1%202cabf6fa1c9244699469e08bd031a524/summary.png)
    
    [https://heeonii.tistory.com/14](https://heeonii.tistory.com/14)
    
    (세마포어랑 뮤텍스 설명)
    
    ## 스레드 파트
    
    ```
    스레드(Thread)
    ```
    
    : CPU 이용의 기본 단위
    
    - 구성 → 스레드 ID + 프로그램 카운터(PC) + 레지스터 집합 + 스택
    - 같은 프로세스에 속한 다른 스레드와 운영체제 자원들을 공유
        - 운영체제 자원들 → 코드, 데이터 섹션, 열린 파일이나 신호 같은 것
    
    - 2가지의 스레드
        - `단일 스레드 프로세스` : 전통적인 프로세스로, 하나의 제어 스레드를 가지고 있다.
            - 한 번에 하나의 작업만 수행할 수 있음
                
                ![https://blog.kakaocdn.net/dn/DnYOO/btstCGLGaHZ/KNWjbSnxbGxc7aMMIKeYl1/img.png](https://blog.kakaocdn.net/dn/DnYOO/btstCGLGaHZ/KNWjbSnxbGxc7aMMIKeYl1/img.png)
                
                단일 스레드 프로세스 내부 구조
                
        - `다중 스레드 프로세스` : 하나의 프로세스가 다수의 제어 스레드를 가지고 있음
            - 동시에 하나 이상의 작업을 수행할 수 있다.
                
                ![https://blog.kakaocdn.net/dn/b6eva9/btstyvYbTzp/Tm0T6tdk3J3Sb4jiDt5J5K/img.png](https://blog.kakaocdn.net/dn/b6eva9/btstyvYbTzp/Tm0T6tdk3J3Sb4jiDt5J5K/img.png)
                
                다중 스레드 프로세스 내부 구조
                
    
    ### **[동기(Motivation)](https://howudong.tistory.com/262#article-2--%EB%8F%99%EA%B8%B0(motivation))**
    
    - 현대의 거의 모든 소프트웨어 응용들은 다중 스레드를 이용한다.
        - 하나의 응용은 몇 개의 실행 흐름을 가진 **독립적인 프로세스**로 구현된다.
            - 예
                - 워드에서 그래픽을 표시하는 스레드, 사용자 키 입력에 응답하는 스레드가 따로 있다.
                - 웹 브라우저는 하나의 스레드가 이미지를 표시하고 다른 스레드는 네트워킹을 할 수 있다.
        - 응용은 다중 코어 시스템에서 처리 능력을 향상하도록 설계될 수 있다.
            - 응용은 다중 계산 코어를 사용하여 다수의 CPU-집중 작업을 병렬로 처리할 수 있다.
    
    ---
    
    ### **[웹 서버에서의 다중 스레드 사용](https://howudong.tistory.com/262#article-3--%EC%9B%B9-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%EC%A4%91-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%82%AC%EC%9A%A9)**
    
    - 만약 웹 서버가 단일 스레드 프로세스로 작동한다고 가정→ 단일 프로세스가 한 번에 하나의 클라이언트만 서비스 가능→ 클라이언트는 자신의 요구가 서비스되기까지 매우 긴 시간을 기다려야 함
    - 해결책
        1. 서버에게 요청이 들어오면, 프로세스는 그 요청을 수행할 별도의 프로세스를 생성하는 방식
            - 스레드가 대중화되기 전엔 보편적이었던 방식
            - 프로세스 생성 작업은 매우 많은 시간과 자원 소모
            - *→* **새 프로세스와 기존 프로세스가 동일한데 굳이 만드는 것은 비효율적**
        2. 프로세스 안에 여러 스레드를 만드는 방식 → 더 효율적인 방식
            
            ![https://blog.kakaocdn.net/dn/bEYGqy/btstxjRrtwy/k55516n7vlk3dN0vDwUyhK/img.png](https://blog.kakaocdn.net/dn/bEYGqy/btstxjRrtwy/k55516n7vlk3dN0vDwUyhK/img.png)
            
            다중 스레드 서버 구조
            
            - 서버는 클라이언트의 요청을 listen 하는 별도의 스레드를 생성
            - 요청이 들어오면 다른 프로세스를 생성하는 것이 아님.
                - 요청을 서비스할 새로운 스레드를 생성함과 동시에추가적인 요청을 listen 하기 위한 작업을 재개
    
    ---
    
    ### **[Linux 시스템에서의 다중 스레드](https://howudong.tistory.com/262#article-4--linux-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%EC%A4%91-%EC%8A%A4%EB%A0%88%EB%93%9C)**
    
    - Linux 시스템에서 시스템을 부트 하는 동안 여러 커널 스레드가 생성
        - 대부분의 운영체제 커널도 일반적으로 다중 스레드
    - 각 스레드는 장치 관리, 메모리 관리 또는 인터럽트 처리와 같은 특정 작업 수행
    - `ps -ef` 명령을 사용하여 실행 중인 Linux 시스템에서 커널 스레드를 표시 가능
    
    ---
    
    ### **[응용 프로그램에서의 다중 스레드](https://howudong.tistory.com/262#article-5--%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%97%90%EC%84%9C%EC%9D%98-%EB%8B%A4%EC%A4%91-%EC%8A%A4%EB%A0%88%EB%93%9C)**
    
    - 많은 응용 프로그램에서 기본 정렬, 트리 및 그래프 알고리즘을 포함하여 다중 스레드를 활용 가능
    - 데이터 마이닝, 그래픽 및 인공지능에서 CPU 중심의 최신 문제를 해결해야 하는 프로그래머→ 병렬로 실행되는 설루션을 설계하여 최신 다중 코어 시스템의 성능 활용 가능
    
    ---
    
    ### **[장점](https://howudong.tistory.com/262#article-6--%EC%9E%A5%EC%A0%90)**
    
    - 다중 스레드 프로그래밍 이점은 `응답성` `자원 공유` `경제성` `규모 적응성` 4가지로 나눌 수 있음
    
    ### **[1. 응답성(responsiveness)](https://howudong.tistory.com/262#article-6-1--1--%EC%9D%91%EB%8B%B5%EC%84%B1(responsiveness))**
    
    - 대화형 응용을 다중 스레드 화하면 사용자에 대한 응답성을 증가시킨다.
        - 응답성을 증가시키는 이유
            - 응용 프로그램의 일부분이 봉쇄되거나, 긴 작업을 수행하더라도, 프로그램의 수행이계속되는 것을 허용하기 때문
    - 해당 특징은 사용자 인터페이스를 설계하는 데 있어 특히 유용
        - 예 : 사용자 시간이 많이 걸리는 연산을 시작하는 단추를 클릭했을 때
            - 단일 스레드 응용 → 그 연산이 완료될 때까지 사용자가 응답하지 않음
            - 별도의 비동기적 스레드 → 응용은 여전히 사용자에게 응답 가능
    
    ### **[2. 자원 공유(resource sharing)](https://howudong.tistory.com/262#article-6-2--2--%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0(resource-sharing))**
    
    - 스레드는 자동으로 자신들이 속한 프로세스의 자원들과 메모리를 공유 → 코드와 데이터를 공유
        - cf ) 프로세스는 공유 메모리와 메시지 전달 기법을 통해서만 자원 공유 가능
    - 코드와 데이터 공유의 이점
        - 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있음
    
    ### **[3. 경제성(economy)](https://howudong.tistory.com/262#article-6-3--3--%EA%B2%BD%EC%A0%9C%EC%84%B1(economy))**
    
    - 스레드를 생성하고 문맥 교환하는 것은 더욱 효과적이다.← 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에
    - 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 소비한다.
    - 문맥 교환(context switching)은 프로세스 사이보다 스레드 사이에서 더 빠르다.
    
    ### **[4. 규모 적응성(scalalbility)](https://howudong.tistory.com/262#article-6-4--4--%EA%B7%9C%EB%AA%A8-%EC%A0%81%EC%9D%91%EC%84%B1(scalalbility))**
    
    - 다중 스레드의 이점은 다중 처리기 구조에서 더욱 증가← 다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있기 때문
        - 단일 스레드 프로세스는 처리기가 아무리 많아도 오직 한 처리기에서만 실행됨
    
    ---
    
    - 프로세스와 스레드의 차이
    
    <메모리 자원 할당에서 차이남(위에 서술됨)
    
    - 다중 코어 프로그래밍
    
    ### **[다중 코어 프로그래밍](https://howudong.tistory.com/262#article-7--%EB%8B%A4%EC%A4%91-%EC%BD%94%EC%96%B4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)**
    
    - `다중 코어` : 단일 컴퓨팅 칩에 여러 컴퓨팅 코어를 배치하는 것
        - 각 코어는 운영체제에 별도의 CPU를 가지고 있음
    
    ### **[각 코어 시스템에 따른 병행 실행](https://howudong.tistory.com/262#article-7-1--%EA%B0%81-%EC%BD%94%EC%96%B4-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90-%EB%94%B0%EB%A5%B8-%EB%B3%91%ED%96%89-%EC%8B%A4%ED%96%89)**
    
    - 다중 스레드 프로그래밍은 컴퓨팅 코어를 보다 효율적으로 사용하고 병행성을 향상하는 기법 제공
    - 스레드가 4개인 응용 프로그램이라고 가정
        - **단일 컴퓨팅 코어가** 있는 시스템의 경우
            
            ![https://blog.kakaocdn.net/dn/qC6di/btstC0J5xya/UJkpWhLPUs9u4cJHVs6EDk/img.png](https://blog.kakaocdn.net/dn/qC6di/btstC0J5xya/UJkpWhLPUs9u4cJHVs6EDk/img.png)
            
            - 인터리브(사이사이에 끼워 넣는 것)되게 실행
        - 다중 컴퓨팅 코어가 있는 시스템의 경우
            
            ![https://blog.kakaocdn.net/dn/cvyFAF/btsts3BSGE7/qCgUQ41SaGsfZ7hBmlOuAK/img.png](https://blog.kakaocdn.net/dn/cvyFAF/btsts3BSGE7/qCgUQ41SaGsfZ7hBmlOuAK/img.png)
            
            다중 코어
            
            - 일부 스레드가 **병렬로 실행**될 수 있음을 의미← 병행성은 시스템이 각 코어에 별도의 스레드를 할당할 수 있기 때문
    
    ### **[병행성 vs 병렬성](https://howudong.tistory.com/262#article-7-2--%EB%B3%91%ED%96%89%EC%84%B1-vs-%EB%B3%91%EB%A0%AC%EC%84%B1)**
    
    - `병행성` : 병행 시스템은 모든 작업이 진행되게 하여 둘 이상의 작업을 지원하는 것
        - 동시에 진행하는 것이 아닌 두 작업을 번갈아가면서 진행하는 것을 의미
    - `병렬성` : 병렬 시스템은 둘 이상의 작업을 **동시에 수행하는 것**
    - 단일 프로세서 → **병렬성 없이 병행성만 가질 수 있다.**
    
    ---
    
    ### **[프로그래밍 도전과제](https://howudong.tistory.com/262#article-8--%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%8F%84%EC%A0%84%EA%B3%BC%EC%A0%9C)**
    
    - 다중 코어 시스템으로의 발전은 응용 프로그래머에게도 다중 코어의 활용도를 높이도록 압박을 줌
        - 운영체제 설계자는 병렬 수행은 위한 여러 코어를 활용하는 스케줄링 알고리즘을 개발해야 함
    - 응용 프로그래머는 기존 프로그램을 다중 스레드를 사용하도록 수정및 다중 스레드 프로그램을 설계해야 하는 도전에 당면해 있음
    - 다중 코어 시스템을 위한 프로그래밍 도전과제는 5개가 존재
        - `태스크 인식(identifying tasks)`
            - 응용을 분석하여 독립된 병행 기능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요
            - 태스크는 서로 독립적이고 따라서 개별 코어에서 병렬 실행될 수 있어야 한다.
        - `균형(balance)`
            - 전체 작업에 균등한 기여도를 가지도록 태스크를 나누는 것도 중요하다.
                - 어떤 경우에는 다른 태스크에 비해 기여도가 적은 작업이 있을 수 있음→ 이런 작업에 별도의 코어를 사용하는 것은 낭비
        - `데이터 분리(data spliting)`
            - 태스크가 접근하고 조작하는 데이터는 개별 코어에서 사용할 수 있도록 나누어져야 한다.
                - 응용이 독립된 태스크로 나누어지는 것과 비슷
        - `데이터 종속성(data dependency)`
            - 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다.
                - 종속적인 경우→ 프로그래머가 데이터 종속성 수용을 위해 태스크의 수행을 잘 동기화해야 함.
        - `시험 및 디버깅(testing and debugging)`
            - 병행 프로그램을 시험하고 디버깅하는 것은 단일 스레드 응용보다 훨씬 어렵다.← 프로그램이 다중 코어에서 병렬로 실행될 때, 다양한 실행 경로로 존재할 수 있기 때문
    
    ---
    
    ### **[병렬 실행의 유형 - 2가지 유형 존재](https://howudong.tistory.com/262#article-9--%EB%B3%91%EB%A0%AC-%EC%8B%A4%ED%96%89%EC%9D%98-%EC%9C%A0%ED%98%95---2%EA%B0%80%EC%A7%80-%EC%9C%A0%ED%98%95-%EC%A1%B4%EC%9E%AC)**
    
    1. `데이터 병렬 실행`
        
        ![https://blog.kakaocdn.net/dn/YZvfM/btstwjEooq6/OMT1k2DQne57CsdZZGZ9Fk/img.png](https://blog.kakaocdn.net/dn/YZvfM/btstwjEooq6/OMT1k2DQne57CsdZZGZ9Fk/img.png)
        
        데이터 병렬 실행
        
        - 동일한 데이터의 부분집합을 다수의 계산 코어에 분배 한 뒤, 각 코어에서 동일한 연산 실행
        - 기본적으로 여러 코어에 데이터를 분배하는 것이 포함
        - 예시 - 크기가 N인 배열의 내용을 더하는 경우
            - 코어 0은 [0 ~ N/2 -1]까지 더하고, 코어 1은 [N/2 ~ N]까지 더함
    2. `태스크 병렬 실행`
        
        ![https://blog.kakaocdn.net/dn/doHepG/btstr2JYAqD/9LC3nIiAkm69acA4KWYy3k/img.png](https://blog.kakaocdn.net/dn/doHepG/btstr2JYAqD/9LC3nIiAkm69acA4KWYy3k/img.png)
        
        태스크 병렬 실행
        
        - 데이터가 아닌 태스크(스레드)를 다수의 코어에 분배. 각 스레드는 고유의 연산을 실행
            - 다른 스레드들이 동일한 데이터에 대해 연산을 실행하거나,서로 다른 데이터에 대해 연산을 실행할 수도 있다.
        - 기본적으로 여러 코어에 태스크를 분배하는 것이 포함
        - 예시 - 크기가 N인 배열의 내용을 더하는 경우
            - 각자 고유한 통계 연산을 수행하는 2개의 스레드가 필요할 수 있음
            - 이 스레드들은 개별 코어에서 병렬로 실행되지만, 각각 고유한 연산을 실행
    - 데이터와 태스크 병렬 처리는 상호 배타적이지 않으며, 이 두 가지 전략을 혼합하여 사용 가능
    - 
    
    - 다중 스레드 모델
    
    ## **[다중 스레드 모델(MultiThreading Model)](https://howudong.tistory.com/268#article-1--%EB%8B%A4%EC%A4%91-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%AA%A8%EB%8D%B8(multithreading-model))**
    
    ### **[수준 차이에 따른 스레드 지원](https://howudong.tistory.com/268#article-1-0-1--%EC%88%98%EC%A4%80-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%A7%80%EC%9B%90)**
    
    ![https://blog.kakaocdn.net/dn/bG8ELy/btstwZTi7A4/IIvkjOhxI9TdGql7Wh2DH0/img.png](https://blog.kakaocdn.net/dn/bG8ELy/btstwZTi7A4/IIvkjOhxI9TdGql7Wh2DH0/img.png)
    
    사용자 스레드와 커널 스레드
    
    - `사용자 스레드(user threads)` : 사용자 수준에서 지원하는 스레드
        - 커널 위에서 지원되고 커널의 지원 없이 관리
    - `커널 스레드(ker-nel threads)` : 커널 수준에서 제공되는 스레드
        - 커널 스레드는 운영체제에 의해 직접 지원되고 관리
        - 거의 모든 현대 운영체제들은 커널 스레드를 지원
    - 궁극적으로 사용자 스레드와 커널 스레드에는 어떤 연관 관계가 존재해야 함.
    
    ---
    
    ### **[다대일 모델(Many-to-One Model)](https://howudong.tistory.com/268#article-1-1--%EB%8B%A4%EB%8C%80%EC%9D%BC-%EB%AA%A8%EB%8D%B8(many-to-one-model))**
    
    ![https://blog.kakaocdn.net/dn/c4EWsu/btsts4AM0tw/4Cf2p94LzjUVemRpyhMPZk/img.png](https://blog.kakaocdn.net/dn/c4EWsu/btsts4AM0tw/4Cf2p94LzjUVemRpyhMPZk/img.png)
    
    다대일 모델
    
    - 많은 사용자 수준 스레드가 하나의 커널 스레드를 사상함
    - 장점
        - 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해짐 → 효율적
    - 단점
        - 한 스레드가 봉쇄형 시스템 콜할 경우, 전체 프로세스가 봉쇄
        - 한 번에 하나의 스레드만 커널에 접근 가능→ 다중 스레드가 다중 코어 시스템에서 병렬 실행 불가능→ 다중 처리 코어의 이점을 살릴 수 없음→ 현재 이 모델을 사용하는 시스템 거의 없음
    - **그린 스레드(green thread)**가 다대일 모델 사용
        - Solaris 시스템을 위한 스레드 라이브러리
    
    ---
    
    ### **[일대일 모델(One-to-One Model)](https://howudong.tistory.com/268#article-1-2--%EC%9D%BC%EB%8C%80%EC%9D%BC-%EB%AA%A8%EB%8D%B8(one-to-one-model))**
    
    ![https://blog.kakaocdn.net/dn/braaWi/btssUHkHSDw/2IsB1R50W9IPvQSaj4dto0/img.png](https://blog.kakaocdn.net/dn/braaWi/btssUHkHSDw/2IsB1R50W9IPvQSaj4dto0/img.png)
    
    - 각 사용자 스레드를 각각 하나의 커널 스레드가 사상
    - 장점
        - 하나의 스레드가 봉쇄적 시스템 콜을 호출해도 다른 스레드가 실행될 수 있음→ 다대일 모델보다 더 많은 병렬성 제공
        - 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용
    - 단점
        - 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 함→ 많은 수의 커널 스레드가 시스템 성능에 부담을 줄 수 있다.
    - Linux, Windows 운영체제 제품군은 일대일 모델을 구현
        - 대부분의 운영체제는 일대일 모델을 사용
    
    ---
    
    ### **[다대다 모델(Many-to-Many-Model)](https://howudong.tistory.com/268#article-1-3--%EB%8B%A4%EB%8C%80%EB%8B%A4-%EB%AA%A8%EB%8D%B8(many-to-many-model))**
    
    ![https://blog.kakaocdn.net/dn/2IU2y/btstwiyOawa/u3pfunjWQNbKXamm2PjET0/img.png](https://blog.kakaocdn.net/dn/2IU2y/btstwiyOawa/u3pfunjWQNbKXamm2PjET0/img.png)
    
    다대다 모델
    
    - 여러 개의 사용자 수준 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 멀티플렉스함
    - 커널 스레드의 수는 응용 프로그램이나 특정 기계에 따라 결정
        - 응용 프로그램은 4개의 코어 시스템보다 8개의 코어 시스템에서더 많은 커널 스레드를 할당받을 수 있음
    - 장점
        - 개발자는 필요한 만큼 사용자 수준 스레드를 생성할 수 있고,상응하는 커널 스레드가 다중 처리기에서 병렬로 수행될 수 있다.
        - 스레드가 봉쇄형 시스템 콜을 발생시켰을 때, 커널이 다른 스레드의 수행을 스케줄 할 수 있다.
    - 단점
        - 구현하기가 어렵다.
        - 구현할 필요가 딱히 없다. ← 커널 스레드 수를 제한하는 것의 중요성이 줄어듦← 대부분의 시스템에서 처리 코어 수가 증가했기 때문
    
    ---
    
    ### **[다대다 모델의 변형 - 두 수준 모델(two-level model)](https://howudong.tistory.com/268#article-1-4--%EB%8B%A4%EB%8C%80%EB%8B%A4-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EB%B3%80%ED%98%95---%EB%91%90-%EC%88%98%EC%A4%80-%EB%AA%A8%EB%8D%B8(two-level-model))**
    
    ![https://blog.kakaocdn.net/dn/bEdnHU/btstCD9e0WK/XzFk1ffFu3KQvzHBqk32H0/img.png](https://blog.kakaocdn.net/dn/bEdnHU/btstCD9e0WK/XzFk1ffFu3KQvzHBqk32H0/img.png)
    
    두 수준 모델
    
    - 많은 사용자 스레드를 적거나 같은 수의 커널 스레드로 멀티플렉스 시키지만,한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것을 허용