# 4주차 운영체제

1. 메모리
    
    메모리란?
    
    각각 주소가 할당된 일련의 바이트의 집합. 
    
    메인 메모리(ram)을 주로 통칭할 때 메모리라고 한다.
    
    프로그램의 실행 시 필요한 주소와 정보를 저장하고 가져다 사용할 수 있게 만드는 공간.(작업 공간)
    
    메모리는 해당 위치를 알려주는 주소가 존재하며, 메모리 주소는 크게 두가지 종류로 나눠진다.
    
    1. 물리적 메모리 주소 : 실제 메모리 상에 존재하는 주소를 의미한다.
    2. 논리적 메모리 주소 : 프로세스에 메모리가 할당이 될 때, 현재 물리 메모리 안에서 실행 중인 메모리의 위치를 나타내는 주소로, 프로세스 내부에서는 0~끝까지를 의미하게 되며, 이 말은 즉, 프로세스 내부에서 사용하는 메모리의 위치를 나타내는 값이다.
    
    - 메모리의 관리가 필요한 이유
    
    각각의 프로세스는 독립된 메모리 공간을 갖고 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않기 때문에 운영체제에서 메모리를 관리한다. 또한, 멀티 프로그래밍 환경으로 변화하면서 한정된 메모리를 효율적으로 사용해야 했고, 운영체제가 이를 어떻게 관리 하는지에 대한 관리 방법이 중요해졌다!
    
    운영체제는 실행 파일이 로더에 의해 메모리에 올라오고 운영체제는 **이 실행 파일을 메모리의 어느 영역에 올릴지 결정하는 것(메모리 할당: 주기억장치에 데이터나 프로그램을 할당하는 것)**이 주 역할이다.
    
   
    <img src="/lkc-os/4주차/img/Untitled.png">
    - 메모리 할당
    
    메모리의 낮은 주소는 운영체제의 영역이고 사용자의 프로세스는 높은 주소에서 사용된다. 
    
    여러가지 기법이 존재하는데 연속 로딩기법(단일,다중 분할 할당), 분산 로딩 기법(비연속적)(페이징(가변크기), 세그멘테이션(고정크기))으로 나눌 수 있다. 
    
    연속적 메모리 할당은 연속된 하나의 큰 메모리에서 프로세스에 메모리를 할당시켜주는 방법이다.
    
       
    <img src="/lkc-os/4주차/img/Untitled 1.png">
    1. 고정크기 메모리할당 : 메모리를 고정된 크기로 나누고 프로세스를 할당시켜준다.(외내부 단편화 발생)
    2. 가변크기 메모리할당 : 프로세스마다 요구되는 메모리 크기에 맞춰서 메모리를 할당시켜준다.(외부 단편화 발생)
    
    <단일 분할 할당이란?> 
    
    한 순간에 하나만 주기억장치의 user영역을 사용하는 기법 
    
    가장 단순하며 운영체제가 사용하는 커널영역과 해당 프로세스의 유저 영역을 구분하는 경계 레지스터를 사용한다.
    
    오버레이 기법과 스와핑 기법을 사용한다.
    
    ### 오버레이
    
    - 프로그램의 메모리가 주 기억장치보다 클 때의 문제를 해결하기 위한 기법
    - 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 순서대로 주기억장치에 적재하여 프로그램을 실행한다.
    - 실행 중에 주기억장치의 메모리가 부족하면 불필요한 조각이 있는 곳에 새로운 조각을 중첩하여 적재한다.
    
 
    <img src="/lkc-os/4주차/img/Untitled 2.png">
    ### 스와핑
    
    - 주기억장치에 적재한 하나의 프로그램과 보조기억장치에 적재한 다른 프로그램의 메모리를 교체하는 기법
    - Swap Out : 주기억장치에 있는 프로그램이 보조기억장치로 이동
    - Swap In : 보조기억장치에 있는 프로그램이 주기억장치로 이동
    - 가상기억장치의 페이징 기법으로 발전하였다.
    
    ---
    
    ### **단편화 현상(연속 메모리 할당에서 발생하는 문제점)**
    
    **: 메모리의 공간이 작은 조각으로 나뉘어 사용 가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태**
    

        <img src="/lkc-os/4주차/img/Untitled 3.png">
    **1. 내부 단편화**
    
    : 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게 되면 2B라는 차이 가 존재하고, 이 현상을 내부 단편화라 칭한다(남는것)
    

        <img src="/lkc-os/4주차/img/Untitled 4.png">
    **2. 외부 단편화**
    
    **:** 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생한다고 볼 수 있다.(프로세스간의 비는 간격)
    
    **※ 단편화 해결법**
    
    coalescing(집약) : 현재 위치의 메모리에서 단편화 메모리들 끼리 인접해 있는 경우 이를 하나의 큰 메모리로 만들어준다.
    
    compaction(압축) : 비 연속적으로 존재하는 단편화 메모리들을 메모리 재배치를 통해 하나의 연속된 큰 메모리로 만들어 준다.
    
    coalescing과 compaction의 차이는 메모리의 재배치가 일어나는가 아닌가에 의해 차이가 난다.
    
    ### **홀 선택 알고리즘 : 동적 메모리 할당 문제.**
    
    연속 메모리 할당의 문제는 결국 단편화다.
    
    장점 : 논리주소를 물리주소로 바꾸는 과정이 단순하다. 내부 단편화가 발생한다.
    
    단점 : 메모리 할당의 유연성이 떨어진다, 외부 단편화문제가 발생한다.
    
    이처럼 단편화가 발생했을 때, 조금더 단편화가 없게 하는 효율을 올리기 위해 단편화 선택 알고리즘이 존재한다.
    
    고정 크기 할당시에는 그냥 빈곳에다 넣으면 된다. (동일한 크기로 메모리를 나눠둿으니까)
    
    가변 크기 할당시에는 홀 리스트를 작성하고, 홀마다 시작주소와 크기를 작성해 둬야한다. 이를 통해서 적절한 홀을 선택하게 된다.
    
    이런 홀을 선택하는 알고리즘은 3개가 있다.
    
    1. First fit : 홀 리스트 주소 중에서 그냥 첫번째 빈 홀에 넣는다.
    1. Best fit : 홀 중에 내부 단편화가 가장 적게 발생하는 홀에 넣게 된다. 홀 크기를 오름차순으로하고 가장 작은 홀에 넣게되는것
    1. Worst fit : 가장 큰 홀에 넣게 된다. 할당후 남는 공간에 다른 프로세스의 할당확률을 높여서 할당 공간을 게속해서 유지하게 하는것이 특징이다
    1. Next fit : first Fit 에서 할당된 후 다음 빈홀부터 다시 검색.
    
    저장 공간의 이용성 : best > first > worst
    
    속도 : first > best > worst
    
    (그림 왼오른쪽 위치바뀜)
        <img src="/lkc-os/4주차/img/Untitled 5.png">

    - 페이징과 세그멘테이션
    
    ### 2) 페이징
    
    가상메모리사용, 외부 단편화 해결, 내부 단편화 존재
    
    하나의 프로세스가 사용하는 **메모리 공간이 연속적이어야 한다는 제약을 없앤** 메모리 관리 방법이다.
    
    외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로,
    
    **물리 메모리는 Frame 이라는 고정 크기로 분리**되어 있고,
    
    **논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리**된다.(페이지 교체 알고리즘에 들어가는 페이지)
    
    페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 **외부 단편화를 해결할 수 있는 큰 장점**이 있다.
    
    하나의 프로세스가 사용하는 공간은 여러 개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있다.
    
    **🔴 단점** : **내부 단편화 문제의 비중이 늘어나게 된다**. 예를들어 페이지 크기가 1,024B이고 프로세스 A 가 3,172B 의 메모리를 요구한다면 3 개의 페이지 프레임(1,024 * 3 = 3,072) 하고도 100B 가 남기 때문에 총 4 개의 페이지 프레임이 필요한 것이다. 결론적으로 4 번째 페이지 프레임에는 924B(1,024 - 100)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하는 것이다.
    
    ### 3) 세그먼테이션(Segmentation)
    
    가상메모리사용, 내부 단편화 해결, 외부 단편화 존재
    
    페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, **서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할**
    
    사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장
    
    **🔴 단점** : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다**.(외부 단편화)**
    
    ### 4) 세그먼테이션 - 페이징 혼용 기법
    
    페이징과 세그먼테이션도 각각 내부 단편화와 외부 단편화가 발생하므로 두 가지 방법을 혼용해서 이러한 단편화를 최대한 줄이는 전략
    
    프로세스를 세그먼트(논리적 기능 단위)로 나눈 다음에 세그먼트를 다시 페이징 단위로 나누어 관리한다.
    
    **🔴 단점 :** 매핑 테이블을 두 번 거쳐야 하므로 속도가 느리다.
    
    가상메모리
    
    # **가상 메모리 등장 배경**
    
    - 초창기 컴퓨터에서는 사용 가능한 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 커야 했음. 그렇지 않을 경우 "메모리 부족" 오류에 의해 해당 애플리케이션을 실행할 수 없었음.
    - 이후 컴퓨터에서는 프로그래머가 애플리케이션의 일부분만 기억장치에 올려 실행하도록 지정할 수 있게 하는 **오버레이 기법**을 사용하여 메모리 부족 문제를 해결하고자 했음. 하지만 이 역시 전반적인 메모리 부족 문제를 해결할 수 없었음. 오버레이를 사용하는 프로그램은 그렇지 않은 프로그램보다는 메모리를 덜 사용했지만, 애초에 시스템이 프로그램을 위한 충분한 메모리를 갖추고 있지 않은 경우에는 결국 똑같은 메모리 부족 오류가 발생했음.
    - 여기에서 더 발전한 **가상 메모리 기법**은 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 **최소한** 얼마만큼의 메모리가 필요한가에 집중하여 문제를 해결하고자 함.
        - 이렇게 접근하는 방식이 가능한 이유는, 메모리 접근은 순차적이고 지역화되어 있기 때문임.
        - 그렇다면 이렇게 애플리케이션의 일부분만 메모리(기억장치)에 올려진다면, 메모리에 올라가지 않는 나머지는 어디에 위치해야 할까? ⇒ 정답은 **보조 기억장치, 즉 디스크**!
        - 가상 메모리의 핵심은 보조 기억장치다.
2. 파일 시스템
    - 파일
    
    ```
    파일(File)은논리적인 저장 단위로, 관련된 정보 자료들의 집합에 이름을 붙인 것이다.컴퓨터 시스템의 편리한 사용을 위해 정보 저장의 일괄된 논리적 관점을 제공한다.일반적으로 레코드(Record) 혹은 블록(Block) 단위로 비휘발성 보조기억장치에 저장된다.
    
    파일 속성(File attribute)또는파일의 메타데이터(metadata)는파일을 관리하기 위한 각종 정보들이다. 파일 자체의 내용은 아니다.파일 이름, 유형, 저장된 위치, 파일 사이즈, 접근 권한, 소유자, 시간(생성/변경/사용) 등 파일에 대한 전반적인 정보를 말한다.
    
    파일 시스템(File System)은운영체제와 모든 데이터, 프로그램의 저장과 접근을 위한 기법을 제공한다.시스템 내의 모든 파일에 관한 정보를 제공하는 계층적 디렉터리 구조이고, 파일 및 파일의 메타데이터, 디렉터리 정보 등을 관리한다.
    
    파티션(Partition)은연속된 저장 공간을 하나 이상의 연속되고 독립적인 영역으로 나누어 사용할 수 있도록 정의한 규약이다. 하나의 물리적 디스크 안에 여러 파티션을 두는 게 일반적이지만, 여러 물리적 디스크를 하나의 파티션으로 구성하기도 한다.
    ```
    
    파일 접근법
    
    ```
    시스템이 제공하는 파일 정보의 접근 방식으로는 순차 접근(Sequential Access)과 직접 접근(Direct Access, Random Access), 색인 접근(Index Access)으로 나뉜다.1. 순차 접근(Sequential Access)가장 단순한 방법으로 파일의 정보가 레코드 순서대로 처리된다. 카세트테이프를 사용하는 방식과 동일하다.현재 위치에서 읽거나 쓰면 offset이 자동으로 증가하고, 뒤로 돌아가기 위해선 되감기가 필요하다.2. 직접 접근(Random Access)파일의 레코드를 임의의 순서로 접근할 수 있다. LP 판을 사용하는 방식과 동일하다.읽기나 쓰기의 순서에 제약이 없으며 현재 위치를 유지할 수 있다면 이를 통해 순차 접근 기능도 구현할 수 있다.3. 색인 접근(Index Access)파일에서 레코드를 찾기 위해 색인을 먼저 찾고 대응되는 포인터를 얻는다. 이를 통해 파일에 직접 접근하여 원하는 데이터를 얻을 수 있다. 따라서 크기가 큰 파일에서 유용하다.
    ```
    
    ![https://blog.kakaocdn.net/dn/n9ifN/btrgvqo8ivJ/5nWEa4e9rKUK9MBtPRqyCK/img.png](https://blog.kakaocdn.net/dn/n9ifN/btrgvqo8ivJ/5nWEa4e9rKUK9MBtPRqyCK/img.png)
    
    ![https://blog.kakaocdn.net/dn/ucSgw/btrgqyn2f1Z/rTRsabKKW7LPca4o5307L0/img.png](https://blog.kakaocdn.net/dn/ucSgw/btrgqyn2f1Z/rTRsabKKW7LPca4o5307L0/img.png)
    
    - 디렉터리 구조
    
    ```
    디렉터리(Directory)는 파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일이다.해당 디렉터리에 속한 파일 이름과 속성들을 포함하고 있고,
     다음과 같은 기능들을 제공한다.파일 찾기(Search)파일 생성(Create)파일 삭제(Delete)디렉터리 나열(List)파일 재명명(Rename)파일 시스템 순회(Traverse)
    
    디렉터리는 어떻게 구성되어야 할까?기본적으로 디렉터리의 파일을 빠르게 탐색할 수 있어야 할 것이다. 또 적절한 이름으로 사용자들이 편리하게 사용할 수 있으면 좋을 것이다. 그리고 파일들을 적절한 분류로 그룹화해두면 사용하기 편리할 것이다. 이를 위해 디렉터리의 논리적 구조를 정의하는 여러 방법들이 있다.
    
    1. 1단계 디렉터리(Single-Level Directory)1단계 디렉터리는모든 파일들이 디렉터리 밑에 존재하는 형태이다. 파일들은 서로 유일한 이름을 가지고 서로 다른 사용자라도 같은 이름을 사용할 수 없다.지원하기도 쉽고 이해하기도 쉽지만, 파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 심각한 제약을 갖는다.
    
    2. 2단계 디렉터리(Two-Level Directory)2단계 디렉터리는각 사용자별로 별도의 디렉터리를 갖는 형태이다.
    UFD : 자신만의 사용자 파일 디렉터리MFD : 사용자의 이름과 계정 번호로 색인되어 있는 디렉터리. 각 엔트리는 사용자의 UFD를 가리킨다.서로 다른 사용자가 같은 이름의 파일을 가질 수 있고 효율적인 탐색이 가능하다. 하지만 그룹화가 불가능하고, 다른 사용자의 파일에 접근해야 하는 경우에는 단점이 된다.
    
    3. 트리 구조 디렉터리(Tree-Structured Directory)사용자들이 자신의 서브 디렉터리(Sub-Directory)를 만들어서 파일을 구성할 수 있다. 하나의 루트 디렉터리를 가지며 모든 파일은 고유한 경로(절대 경로/상대 경로)를 가진다. 이를 통해 효율적인 탐색이 가능하고, 그룹화가 가능하다.디렉터리는 일종의 파일이므로 일반 파일인지 디렉터리인지 구분할 필요가 있다. 이를 bit를 사용하여 0이면 일반 파일, 1이면 디렉터리로 구분한다.
    
    4. 비순환 그래프 디렉터리(Acyclic-Graph Directory)디렉터리들이 서브 디렉터리들과 파일을 공유할 수 있도록 한다. 트리 구조의 디렉터리를 일반화한 형태이다.단순한 트리 구조보다는 더 복잡한 구조이기 때문에 몇몇 문제가 발생할 수 있다.파일을 무작정 삭제하게 되면 현재 파일을 가리키는 포인터는 대상이 사라지게 된다. 따라서 참조되는 파일에 참조 계수를 두어서, 참조 계수가 0이 되면 파일을 참조하는 링크가 존재하지 않는다는 의미이므로 그때 파일을 삭제할 수 있도록 한다.
    
    5. 일반 그래프 디렉터리(General Graph Directory)순환을 허용하는 그래프 구조이다. 순환이 허용되면 무한 루프에 빠질 수 있다.따라서, 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나 garbage collection을 통해 전체 파일 시스템을 순회하고, 접근 가능한 모든 것을 표시한다.
    ```
    
    ![https://blog.kakaocdn.net/dn/bbk9x6/btrgpwxekSY/LC5Y2BhsAypMTbdWfMToRK/img.png](https://blog.kakaocdn.net/dn/bbk9x6/btrgpwxekSY/LC5Y2BhsAypMTbdWfMToRK/img.png)
    
    ![https://blog.kakaocdn.net/dn/lLfBK/btrgxCCjMG6/eRQ02qksvFI7JIGQZ2KZdK/img.png](https://blog.kakaocdn.net/dn/lLfBK/btrgxCCjMG6/eRQ02qksvFI7JIGQZ2KZdK/img.png)
    
    ![https://blog.kakaocdn.net/dn/k8pMk/btrgx0JQ4zK/Zw5OniN9knvCQxKTDBJ3P1/img.png](https://blog.kakaocdn.net/dn/k8pMk/btrgx0JQ4zK/Zw5OniN9knvCQxKTDBJ3P1/img.png)
    
    ![https://blog.kakaocdn.net/dn/c1f9RF/btrgvUpXqh3/IDPjd6TkDgHQYuURltRmKk/img.png](https://blog.kakaocdn.net/dn/c1f9RF/btrgvUpXqh3/IDPjd6TkDgHQYuURltRmKk/img.png)
    
    ![https://blog.kakaocdn.net/dn/bTWgpK/btrgC55TQPU/eFeUEtjgM8pbkyRsq4eX3K/img.png](https://blog.kakaocdn.net/dn/bTWgpK/btrgC55TQPU/eFeUEtjgM8pbkyRsq4eX3K/img.png)
    
    - 파일 할당 방법
    
    ```
    파일 데이터를 디스크에 할당하는 방법으로 다음 세 방식이 존재한다.
    Contiguous Allocation
    Linked Allocation
    Indexed Allocation
    
    1. Contiguous Allocation연속 할당(Contiguous Allocation)은 말 그대로 파일을 디스크에 연속되게 저장하는 방식이다.디렉터리에는 파일이 시작 부분의 위치와 파일의 길이에 대한 정보를 저장하면 전체를 탐색할 수 있다.이 방식은 연속적으로 저장되어 있으므로 한 번의 탐색으로 많은 양을 전송할 수 있다. 그리고 Random access가 가능하다.하지만, 외부 단편화가 발생하며, 파일의 크기를 키우기가 어렵다. 파일의 커질 가능성을 고려해서 미리 큰 공간을 할당한다면 내부 단편화가 발생할 수도 있다.
    
    2. Linked Allocation연결 할당(Linked Allocation)은, 연속적으로 할당하지 않고 빈 위치면 자유롭게 할당될 수 있다. 그리고 다음 읽어야 할 위치를 연결 리스트처럼 포인터로 가리킨다. 따라서 디렉터리에는 파일이 시작하는 위치와 끝나는 위치만 저장된다.이 방식은 외부 단편화가 발생하지 않는다는 단점이 있다.하지만, Random access가 불가능하고, 포인터를 위한 공간이 block의 일부가 되어 공간 효율성을 떨어뜨린다.주로 한 sector당 512byte를 배정하는데, 4byte의 포인터를 위한 공간이 사용되면 512byte의 배수로 할당하기 위해서는 포인터를 위해 한 sector만큼 공간이 소모되는 비효율이 발생한다.또, 만약 한 sector가 고장 나 포인터가 유실되면 많은 부분을 잃게 되는 신뢰성 문제도 있다.이러한 단점을 보완하기 위해 FAT(File-allocation table)이라는 파일 시스템을 사용한다. 이는 포인터를 별도의 위치에 보관하여 신뢰성 문제와 공간 효율성 문제를 해결한다.
    
    3. Indexed Allocation색인 할당(Indexed Allocation)은 한 블록에 하나의 파일에 대한 데이터의 index들을 모두 저장하는 방식이다. 따라서 디렉터리에는 해당 블록의 위치만 담게 된다.이 방식은 외부 단편화가 발생하지 않으며 Random access가 가능하다.다만, 작은 파일인 경우 위치를 저장하는 블록의 공간 낭비가 생기고, 너무 큰 파일인 경우엔 하나의 블록으로 파일의 index들을 모두 저장하기에 부족하게 되는 단점이 있다.
    ```
    
    ![https://blog.kakaocdn.net/dn/AtEx7/btrgCG6nwMN/xisipfbEKJmU3oqruPNkVk/img.png](https://blog.kakaocdn.net/dn/AtEx7/btrgCG6nwMN/xisipfbEKJmU3oqruPNkVk/img.png)
    
    ![https://blog.kakaocdn.net/dn/AvQSs/btrgBmt1eAM/22IaMokJ25BqTFM0pwFNuK/img.png](https://blog.kakaocdn.net/dn/AvQSs/btrgBmt1eAM/22IaMokJ25BqTFM0pwFNuK/img.png)
    
    ![https://blog.kakaocdn.net/dn/kWG75/btrgALVnO6k/bj8UJ2IjR2MJnMYEipXxck/img.png](https://blog.kakaocdn.net/dn/kWG75/btrgALVnO6k/bj8UJ2IjR2MJnMYEipXxck/img.png)
    
    - 파티션과 마운팅
    
    **파일 시스템 마운팅(File System Mounting)과 파티션 마운팅(PartitionMounting)**
    
    **[파일마운팅(File Mount)]**
    
    파일이 사용되기 전에 열리는 것처럼 파일 시스템은 프로세스들에 의해 사용되기 전에 장착(mount) 되어야 한다.
    
    마운트 과정은 다음과 같다.
    
    1.     운영체제에게 장치 이름과 파일 시스템을 부착 할 수 있는 파일 구조 내의 위치가 주어진다. 일반적으로 마운트 포인트는 장착되는 파일 시스템이 부착될 비어있는 디렉토리이다.
    
    2.     운영체제는 장치가 유효한 파일 시스템을 포함하는지 확인 한다. 그 과정은 장치 드라이버가 장치 디렉토리를 읽고 디렉토리가 유효한 포맷을 가지고 있는지 확인하도록 요청 함으로써이루어 진다.
    
    3.     운영체제는 파일 시스템이 지정된 마운트 포인트에 장착되었음을 디렉토리 구조에 기록한다. 이 기법은 운영체제가 디렉토리 구조를 순회하고 파일 시스템을 적절히 교체할 수 있게 한다.
    
    ![https://mblogthumb-phinf.pstatic.net/20130715_227/jevida_1373854191972rRehm_PNG/1.png?type=w2](https://mblogthumb-phinf.pstatic.net/20130715_227/jevida_1373854191972rRehm_PNG/1.png?type=w2)
    
    시스템은 파일을 포함하고 있는 디렉토리에 대해 장착을 허가하지 않거나 장착된 파일 시스템만 그 디렉토리에서 사용가능하게 하고 기존 파일들은 탈착 될 때까지 사용 불가능하게 만들 수 있다.  탈착 후에는 장착되었던 파일 시스템은 사용이 끝나고 기존 파일들이 다시사용 가능해진다.
    
    **[파티션과마운팅(Partition and Mounting)]**
    
    디스크의 배치는 운영체제에 따라 크게 달라진다. 각 파티션은 파일시스템을 포함하지 않은 ‘비가공(raw) 파티션이나 파일시스템을 포함하는 ‘가공(cooked)’ 파티션으로 나누어진다.
    
    비가공(raw) 디스크는 어떤 파일 시스템도 적당하지 않은 곳에 사용된다. UNIX의 스왑 공간은 자신의 고유 포맷을 사용하고 파일 시스템을 사용하지 않으므로 비가공 파티션을사용한다. 또한 비가공 디스크는 RAID 시스템에서 필요한정보를 저장할 수 있다. 어느 블록이 미러드(mirrored) 되었는지또는 어느 블록이 변경되어 미러드 될 필요가 있는지 가리키는 비트맵(bitmap)을 가지고 있다.
    
    부트정보는 별도의 파티션에 저장될 수 있다. 부트 할 때 시스템은파일 시스템 장치 드라이버가 적재되어 있지 않으며 파일 시스템 포맷을 해석할 수 없으므로 부트정보는 자신의 포맷을 가진다. 부트 정보는 통상 일련의 순차 블록으로 메모리 하나의 이미지로 적재 된다. 이미지의실행은 첫 번째 바이트 같은 미리 정해진 위치에서부터 시작 된다.
    
    PC들은 이중 부트(dualboot) 시스템을 할 수 있다. 이는 다수의 운영체제가 구축 될 수 있음을 의미한다. 여러 파일 시스템과 여러 운영체제를 인식하는 부트적재기가 부트 공간을 점유하고 일단 적재되면 그 디스크에서이용 가능한 운영체제 중 하나를 부트 할 수 있다.
    
    운영체제 커널과 다른 시스템 파일을 포함할 수 있는 루트 파티션(rootpartition)은 부트 시에 장착 된다. 다른 파티션은 운영체제에 따라 부트 시 자동장착되거나 수동으로 나중에 장착 된다. 운영체제는 장치 드라이버에게 장치 디렉토리를 읽도록 요청하고디렉토리가 유효한 포맷을 가졌는지 확인함으로써 이 과정을 실행 한다. 마지막으로 운영체제는 메모리 내부의마운트 테이블(mount table) 구조에 파일 시스템이 장착되었다는 사실과 파일 시스템의 유형을기록 한다.
    
    [https://velog.io/@passion_man/운영체제-8.-메모리-관리](https://velog.io/@passion_man/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-8.-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC)
    
    [https://techblog-history-younghunjo1.tistory.com/511](https://techblog-history-younghunjo1.tistory.com/511)
    
    [https://baebalja.tistory.com/428](https://baebalja.tistory.com/428)
    
    [https://ahnanne.tistory.com/15](https://ahnanne.tistory.com/15)
    
    [https://rebro.kr/181](https://rebro.kr/181)
